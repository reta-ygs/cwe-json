{"@ID": "1244", "@Name": "Internal Asset Exposed to Unsafe Debug Access Level or State", "@Abstraction": "Base", "@Structure": "Simple", "@Status": "Stable", "Description": "The product uses physical debug or test\n        interfaces with support for multiple access levels, but it\n        assigns the wrong debug access level to an internal asset,\n        providing unintended access to the asset from untrusted debug\n        agents.", "Extended_Description": {"xhtml:p": ["Debug authorization can have multiple levels of\n\t  access, defined such that different system internal assets\n\t  are accessible based on the current authorized debug\n\t  level. Other than debugger authentication (e.g., using\n\t  passwords or challenges), the authorization can also be\n\t  based on the system state or boot stage. For example, full\n\t  system debug access might only be allowed early in boot\n\t  after a system reset to ensure that previous session data is\n\t  not accessible to the authenticated debugger.", "If this protection mechanism does not ensure that\n          internal assets have the correct debug access level during\n          each boot stage or change in system state, an attacker could\n          obtain sensitive information from the internal asset using a\n          debugger."]}, "Related_Weaknesses": {"Related_Weakness": {"@Nature": "ChildOf", "@CWE_ID": "863", "@View_ID": "1000", "@Ordinal": "Primary"}}, "Weakness_Ordinalities": {"Weakness_Ordinality": {"Ordinality": "Primary"}}, "Applicable_Platforms": {"Language": {"@Class": "Not Language-Specific", "@Prevalence": "Undetermined"}, "Operating_System": {"@Class": "Not OS-Specific", "@Prevalence": "Undetermined"}, "Architecture": {"@Class": "Not Architecture-Specific", "@Prevalence": "Undetermined"}, "Technology": {"@Class": "System on Chip", "@Prevalence": "Undetermined"}}, "Modes_Of_Introduction": {"Introduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation"}]}, "Common_Consequences": {"Consequence": [{"Scope": "Confidentiality", "Impact": "Read Memory"}, {"Scope": "Integrity", "Impact": "Modify Memory"}, {"Scope": ["Authorization", "Access Control"], "Impact": ["Gain Privileges or Assume Identity", "Bypass Protection Mechanism"]}]}, "Detection_Methods": {"Detection_Method": {"Method": "Manual Analysis", "Description": "Check 2 devices for their passcode to authenticate access to JTAG/debugging ports. If the passcodes are missing or the same, update the design to fix and retest. Check communications over JTAG/debugging ports for encryption. If the communications are not encrypted, fix the design and retest.", "Effectiveness": "Moderate"}}, "Potential_Mitigations": {"Mitigation": [{"Phase": ["Architecture and Design", "Implementation"], "Description": {"xhtml:p": "For security-sensitive assets accessible over debug/test interfaces, only allow trusted agents."}, "Effectiveness": "High"}, {"Phase": "Architecture and Design", "Description": "Apply blinding [REF-1219] or masking techniques in strategic areas.", "Effectiveness": "Limited"}, {"Phase": "Implementation", "Description": "Add shielding or tamper-resistant protections to the device, which increases the difficulty and cost for accessing debug/test interfaces.", "Effectiveness": "Limited"}]}, "Demonstrative_Examples": {"Demonstrative_Example": {"Intro_Text": "The JTAG interface is used to perform debugging and provide CPU core access for developers. JTAG-access protection is implemented as part of the JTAG_SHIELD bit in the hw_digctl_ctrl register. This register has no default value at power up and is set only after the system boots from ROM and control is transferred to the user software.", "Example_Code": [{"@Nature": "Bad", "@Language": "Other", "xhtml:table": {"xhtml:tbody": {"xhtml:tr": [{"xhtml:td": ["1 bit", "0x0 = JTAG debugger is enabled (default)"]}, {"xhtml:td": ["JTAG_SHIELD", "0x1 = JTAG debugger is disabled"]}]}}}, {"@Nature": "Informative", "xhtml:div": "The default value of this register bit should be set to 1 to prevent the JTAG from being enabled at system reset."}], "Body_Text": "This means that since the end user has access to JTAG at system reset and during ROM code execution before control is transferred to user software, a JTAG user can modify the boot flow and subsequently disclose all CPU information, including data-encryption keys."}}, "Observed_Examples": {"Observed_Example": {"Reference": "CVE-2019-18827", "Description": "After ROM code execution, JTAG access is disabled. But before the ROM code is executed, JTAG access is possible, allowing a user full system access.  This allows a user to modify the boot flow and successfully bypass the secure-boot process.", "Link": "https://www.cve.org/CVERecord?id=CVE-2019-18827"}}, "Related_Attack_Patterns": {"Related_Attack_Pattern": {"@CAPEC_ID": "114"}}, "References": {"Reference": [{"@External_Reference_ID": "REF-1056"}, {"@External_Reference_ID": "REF-1057"}, {"@External_Reference_ID": "REF-1219"}]}, "Notes": {"Note": {"@Type": "Relationship", "#text": "CWE-1191 and CWE-1244 both involve physical debug access,\n\t  but the weaknesses are different. CWE-1191 is effectively\n\t  about missing authorization for a debug interface,\n\t  i.e. JTAG.  CWE-1244 is about providing internal assets with\n\t  the wrong debug access level, exposing the asset to\n\t  untrusted debug agents."}}, "Content_History": {"Submission": {"Submission_Name": "Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi", "Submission_Organization": "Intel Corporation", "Submission_Date": "2020-02-12"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-08-20", "Modification_Comment": "updated Demonstrative_Examples, Name, Observed_Examples, Related_Attack_Patterns"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2021-03-15", "Modification_Comment": "updated Maintenance_Notes"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2021-10-28", "Modification_Comment": "updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, References, Relationship_Notes, Relationships, Weakness_Ordinalities"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2022-04-28", "Modification_Comment": "updated Related_Attack_Patterns"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated References, Relationships"}], "Contribution": {"@Type": "Content", "Contribution_Name": "Hareesh Khattri", "Contribution_Organization": "Intel Corporation", "Contribution_Date": "2021-10-22", "Contribution_Comment": "clarified differences between CWE-1191 and CWE-1244, and suggested rephrasing of descriptions and names."}, "Previous_Entry_Name": [{"@Date": "2020-08-20", "#text": "Improper Authorization on Physical Debug and Test Interfaces"}, {"@Date": "2021-10-28", "#text": "Improper Access to Sensitive Information Using Debug and Test Interfaces"}]}}