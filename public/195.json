{"@ID": "195", "@Name": "Signed to Unsigned Conversion Error", "@Abstraction": "Variant", "@Structure": "Simple", "@Status": "Draft", "Description": "The product uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive.", "Extended_Description": {"xhtml:p": ["It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program.", "Often, functions will return negative values to indicate a failure. When the result of a function is to be used as a size parameter, using these negative return values can have unexpected results. For example, if negative size values are passed to the standard memory copy or allocation functions they will be implicitly cast to a large unsigned value. This may lead to an exploitable buffer overflow or underflow condition."]}, "Related_Weaknesses": {"Related_Weakness": [{"@Nature": "ChildOf", "@CWE_ID": "681", "@View_ID": "1000", "@Ordinal": "Primary"}, {"@Nature": "ChildOf", "@CWE_ID": "681", "@View_ID": "1305", "@Ordinal": "Primary"}, {"@Nature": "ChildOf", "@CWE_ID": "681", "@View_ID": "1340", "@Ordinal": "Primary"}, {"@Nature": "CanPrecede", "@CWE_ID": "119", "@View_ID": "1000"}]}, "Applicable_Platforms": {"Language": [{"@Name": "C", "@Prevalence": "Undetermined"}, {"@Name": "C++", "@Prevalence": "Undetermined"}]}, "Modes_Of_Introduction": {"Introduction": {"Phase": "Implementation"}}, "Common_Consequences": {"Consequence": {"Scope": "Integrity", "Impact": "Unexpected State", "Note": "Conversion between signed and unsigned values can lead to a variety of errors, but from a security standpoint is most commonly associated with integer overflow and buffer overflow vulnerabilities."}}, "Detection_Methods": {"Detection_Method": {"@Detection_Method_ID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}}, "Demonstrative_Examples": {"Demonstrative_Example": [{"@Demonstrative_Example_ID": "DX-73", "Intro_Text": "In this example the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned int, amount will be implicitly converted to unsigned.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:br": [null, null, null, null, null], "#text": "int amount = 0;...if (result == ERROR)amount = -1;...return amount;"}, "#text": "unsigned int readdata () {}"}}, "Body_Text": "If the error condition in the code above is met, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers."}, {"@Demonstrative_Example_ID": "DX-74", "Intro_Text": "In this example, depending on the return value of accecssmainframe(), the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned value, amount will be implicitly cast to an unsigned number.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:br": [null, null, null, null], "#text": "int amount = 0;...amount = accessmainframe();...return amount;"}, "#text": "unsigned int readdata () {}"}}, "Body_Text": "If the return value of accessmainframe() is -1, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers."}, {"@Demonstrative_Example_ID": "DX-21", "Intro_Text": "The following code is intended to read an incoming packet from a socket and extract one or more headers.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "#text": "ExitError(\"too many headers!\");"}, "#text": "DataPacket *packet;int numHeaders;PacketHeader *headers;\n                     sock=AcceptSocketConnection();ReadPacket(packet, sock);numHeaders =packet->headers;\n                     if (numHeaders > 100) {}headers = malloc(numHeaders * sizeof(PacketHeader);ParsePacketHeaders(packet, headers);"}}, "Body_Text": "The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}, {"Intro_Text": "This example processes user input comprised of a series of variable-length structures. The first 2 bytes of input dictate the size of the structure to be processed.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:br": [null, null, null, null], "xhtml:div": [{"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "memcpy(buf, strm, len);process(buf);return strm + len;"}, {"@style": "margin-left:1em;", "#text": "return -1;"}], "#text": "char buf[512];short len = *(short*) strm;strm += sizeof(len);if (len <= 512) {}else {}"}, "#text": "char* processNext(char* strm) {}"}}, "Body_Text": "The programmer has set an upper bound on the structure size: if it is larger than 512, the input will not be processed. The problem is that len is a signed short, so the check against the maximum structure length is done with signed values, but len is converted to an unsigned integer for the call to memcpy() and the negative bit will be extended to result in a huge value for the unsigned integer. If len is negative, then it will appear that the structure has an appropriate size (the if branch will be taken), but the amount of memory copied by memcpy() will be quite large, and the attacker will be able to overflow the stack with data in strm."}, {"@Demonstrative_Example_ID": "DX-114", "Intro_Text": "In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": [{"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null], "xhtml:i": ["/* if chunk info is valid, return the size of usable memory,", "* else, return -1 to indicate an error", "*/"], "#text": "..."}}, {"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "...memcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));..."}], "xhtml:br": null, "#text": "int returnChunkSize(void *) {}int main() {}"}}, "Body_Text": "If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."}, {"@Demonstrative_Example_ID": "DX-138", "Intro_Text": "This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:br": [null, null, null, null, null, null, null], "xhtml:div": {"xhtml:i": ["// Note space at the end of the string - assume all strings have preamble with space", "... Do processing here if we get this far"], "xhtml:br": [null, null, null], "#text": "int pre_len = sizeof(\"preamble: \");\n\t\t    char buf[pre_len - msg_len];"}, "#text": "int proc_msg(char *s, int msg_len)\n\t\t {\n                  \n\t\t  }\n\t\t  char *s = \"preamble: message\\n\";\n\t\t  char *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\n\t\t  int jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\n\t\t  int ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack"}, "Body_Text": "The buffer length ends up being -1, resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations."}]}, "Observed_Examples": {"Observed_Example": {"Reference": "CVE-2007-4268", "Description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)", "Link": "https://www.cve.org/CVERecord?id=CVE-2007-4268"}}, "Taxonomy_Mappings": {"Taxonomy_Mapping": [{"@Taxonomy_Name": "CLASP", "Entry_Name": "Signed to unsigned conversion error"}, {"@Taxonomy_Name": "Software Fault Patterns", "Entry_ID": "SFP1", "Entry_Name": "Glitch in computation"}, {"@Taxonomy_Name": "CERT C Secure Coding", "Entry_ID": "INT31-C", "Entry_Name": "Ensure that integer conversions do not result in lost or misinterpreted data", "Mapping_Fit": "CWE More Specific"}]}, "References": {"Reference": [{"@External_Reference_ID": "REF-62", "@Section": "Chapter 6, \"Type Conversions\", Page 223"}, {"@External_Reference_ID": "REF-18"}]}, "Content_History": {"Submission": {"Submission_Name": "CLASP", "Submission_Date": "2006-07-19"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2008-09-08", "Modification_Comment": "updated Applicable_Platforms, Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2009-05-27", "Modification_Comment": "updated Demonstrative_Examples"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2009-10-29", "Modification_Comment": "updated Common_Consequences, Description, Other_Notes, Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2010-02-16", "Modification_Comment": "updated Demonstrative_Examples"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2010-04-05", "Modification_Comment": "updated Demonstrative_Examples"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-03-29", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-06-01", "Modification_Comment": "updated Common_Consequences"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-06-27", "Modification_Comment": "updated Common_Consequences"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-05-11", "Modification_Comment": "updated Demonstrative_Examples, References, Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2014-06-23", "Modification_Comment": "updated Demonstrative_Examples, Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2014-07-30", "Modification_Comment": "updated Relationships, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2017-01-19", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2017-11-08", "Modification_Comment": "updated Observed_Examples, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2019-01-03", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-02-24", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-08-20", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-12-10", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2021-03-15", "Modification_Comment": "updated Demonstrative_Examples, References"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-01-31", "Modification_Comment": "updated Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated Detection_Factors, Relationships"}]}}