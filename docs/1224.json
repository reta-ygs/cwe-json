{"cwe": {"@ID": "1224", "@Name": "Improper Restriction of Write-Once Bit Fields", "@Abstraction": "Base", "@Structure": "Simple", "@Status": "Incomplete", "Description": "The hardware design control register \"sticky bits\" or write-once bit fields are improperly implemented, such that they can be reprogrammed by software.", "Extended_Description": {"xhtml:p": ["Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to define default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make the settings write-once or \"sticky.\" This allows writing to such registers only once, whereupon they become read-only. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings.", "Failure to implement write-once restrictions in hardware design can expose such registers to being re-programmed by software and written multiple times. For example, write-once fields could be implemented to only be write-protected if they have been set to value \"1\", wherein they would work as \"write-1-once\" and not \"write-once\"."]}, "Related_Weaknesses": {"Related_Weakness": {"@Nature": "ChildOf", "@CWE_ID": "284", "@View_ID": "1000", "@Ordinal": "Primary"}}, "Applicable_Platforms": {"Language": [{"@Name": "Verilog", "@Prevalence": "Undetermined"}, {"@Name": "VHDL", "@Prevalence": "Undetermined"}], "Technology": {"@Class": "System on Chip", "@Prevalence": "Undetermined"}}, "Modes_Of_Introduction": {"Introduction": [{"Phase": "Architecture and Design"}, {"Phase": "Implementation", "Note": "Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases."}]}, "Common_Consequences": {"Consequence": {"Scope": ["Confidentiality", "Integrity", "Availability", "Access Control"], "Impact": "Varies by Context", "Note": "System configuration cannot be programmed in a secure way."}}, "Potential_Mitigations": {"Mitigation": [{"Phase": "Architecture and Design", "Description": "During hardware design all register write-once or sticky fields must be evaluated for proper configuration."}, {"Phase": "Testing", "Description": "The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros."}]}, "Demonstrative_Examples": {"Demonstrative_Example": {"Intro_Text": "Consider the example design module system verilog code shown below. register_write_once_example module is an example of register that has a write-once field defined. Bit 0 field captures the write_once_status value. This implementation can be for a register that is defined by specification to be a write-once register, since the write_once_status field gets written by input data bit 0 on first write.", "Example_Code": [{"@Nature": "Bad", "@Language": "Verilog", "xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:br": [null, null, null, null, null, null, null, null, null], "xhtml:div": [{"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "Data_out <= 16'h0000;\n\t\t\t  Write_once_status <= 1'b0;"}, {"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "Data_out <= Data_in & 16'hFFFE;\n\t\t\t  Write_once_status <= Data_in[0]; // Input bit 0 sets Write_once_status"}, {"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "Data_out[15:1] <= Data_out[15:1]; \n\t\t\t  Data_out[0] <= Write_once_status;"}], "#text": "if (~ip_resetn)\n\t\t\tbegin\n\t\t\t\n\t\t\tend \n\t\t\telse if (write & ~Write_once_status)\n\t\t\tbegin\n\t\t\t\n\t\t\tend\n\t\t\telse if (~write)\n\t\t\tbegin \n\t\t\t\n\t\t\tend"}, "#text": "module register_write_once_example\n\t\t      ( \n\t\t      input [15:0] Data_in, \n\t\t      input Clk, \n\t\t      input ip_resetn, \n\t\t      input global_resetn,\n\t\t      input write,\n\t\t      output reg [15:0] Data_out \n\t\t      );\n\t\t      \n\t\t      reg Write_once_status; \n                      \n\t\t      always @(posedge Clk or negedge ip_resetn)\n\t\t      \n\t\t\tendmodule"}, {"@Nature": "Good", "@Language": "Verilog", "xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:br": [null, null, null, null, null, null, null, null, null], "xhtml:div": [{"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "Data_out <= 16'h0000; \n\t\t\t    Write_once_status <= 1'b0;"}, {"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "Data_out <= Data_in & 16'hFFFE; \n\t\t\t    Write_once_status <= 1'b1; // Write once status set on first write, independent of input"}, {"@style": "margin-left:1em;", "xhtml:br": [null, null], "#text": "Data_out[15:1] <= Data_out[15:1]; \n\t\t\t    Data_out[0] <= Write_once_status;"}], "#text": "if (~ip_resetn) \n\t\t\t  begin \n\t\t\t  \n\t\t\t  end \n\t\t\t  else if (write & ~Write_once_status) \n\t\t\t  begin \n\t\t\t  \n\t\t\t  end \n\t\t\t  else if (~write) \n\t\t\t  begin \n\t\t\t  \n\t\t\t  end"}, "#text": "module register_write_once_example \n\t\t\t( \n\t\t\tinput [15:0] Data_in, \n\t\t\tinput Clk, \n\t\t\tinput ip_resetn, \n\t\t\tinput global_resetn, \n\t\t\tinput write, \n\t\t\toutput reg [15:0] Data_out \n\t\t\t); \n\t\t\t\n\t\t\treg Write_once_status; \n                        \n\t\t\talways @(posedge Clk or negedge ip_resetn) \n\t\t\t\n\t\t\t\n\t\t\tendmodule"}], "Body_Text": "The above example only locks further writes if write_once_status bit is written to one. So it acts as write_1-Once instead of the write-once attribute."}}, "Related_Attack_Patterns": {"Related_Attack_Pattern": {"@CAPEC_ID": "680"}}, "Content_History": {"Submission": {"Submission_Name": "Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi", "Submission_Organization": "Intel Corporation", "Submission_Date": "2019-12-12"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-08-20", "Modification_Comment": "updated Related_Attack_Patterns"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2022-04-28", "Modification_Comment": "updated Related_Attack_Patterns"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2022-10-13", "Modification_Comment": "updated Demonstrative_Examples"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated Relationships"}]}}, "copyright": "Copyright \u00a9 2006\u20132023, The MITRE Corporation. CWE, CWSS, CWRAF, and the CWE logo are trademarks of The MITRE Corporation.", "license": "CWE Usage: MITRE hereby grants you a non-exclusive, royalty-free license to use CWE for research, development, and commercial purposes. Any copy you make for such purposes is authorized on the condition that you reproduce MITRE\u2019s copyright designation and this license in any such copy."}