{"cwe": {"@ID": "839", "@Name": "Numeric Range Comparison Without Minimum Check", "@Abstraction": "Base", "@Structure": "Simple", "@Status": "Incomplete", "Description": "The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.", "Extended_Description": {"xhtml:p": ["Some products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption.", "The use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account."]}, "Related_Weaknesses": {"Related_Weakness": [{"@Nature": "ChildOf", "@CWE_ID": "1023", "@View_ID": "1000", "@Ordinal": "Primary"}, {"@Nature": "CanPrecede", "@CWE_ID": "195", "@View_ID": "1000"}, {"@Nature": "CanPrecede", "@CWE_ID": "682", "@View_ID": "1000"}, {"@Nature": "CanPrecede", "@CWE_ID": "119", "@View_ID": "1000"}, {"@Nature": "CanPrecede", "@CWE_ID": "124", "@View_ID": "1000"}]}, "Applicable_Platforms": {"Language": [{"@Name": "C", "@Prevalence": "Often"}, {"@Name": "C++", "@Prevalence": "Often"}]}, "Alternate_Terms": {"Alternate_Term": {"Term": "Signed comparison", "Description": "The \"signed comparison\" term is often used to describe when the product uses a signed variable and checks it to ensure that it is less than a maximum value (typically a maximum buffer size), but does not verify that it is greater than 0."}}, "Common_Consequences": {"Consequence": [{"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": ["Modify Application Data", "Execute Unauthorized Code or Commands"], "Note": "An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands."}, {"Scope": "Availability", "Impact": "DoS: Resource Consumption (Other)", "Note": "in some contexts, a negative value could lead to resource consumption."}, {"Scope": ["Confidentiality", "Integrity"], "Impact": ["Modify Memory", "Read Memory"], "Note": "If a negative value is used to access memory, buffers, or other indexable structures, it could access memory outside the bounds of the buffer."}]}, "Potential_Mitigations": {"Mitigation": [{"Phase": "Implementation", "Strategy": "Enforcement by Conversion", "Description": "If the number to be used is always expected to be positive, change the variable type from signed to unsigned or size_t."}, {"Phase": "Implementation", "Strategy": "Input Validation", "Description": "If the number to be used could have a negative value based on the specification (thus requiring a signed value), but the number should only be positive to preserve code correctness, then include a check to ensure that the value is positive."}]}, "Demonstrative_Examples": {"Demonstrative_Example": [{"@Demonstrative_Example_ID": "DX-21", "Intro_Text": "The following code is intended to read an incoming packet from a socket and extract one or more headers.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "#text": "ExitError(\"too many headers!\");"}, "#text": "DataPacket *packet;int numHeaders;PacketHeader *headers;\n                     sock=AcceptSocketConnection();ReadPacket(packet, sock);numHeaders =packet->headers;\n                     if (numHeaders > 100) {}headers = malloc(numHeaders * sizeof(PacketHeader);ParsePacketHeaders(packet, headers);"}}, "Body_Text": "The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}, {"@Demonstrative_Example_ID": "DX-23", "Intro_Text": "The following code reads a maximum size and performs a sanity check on that size. It then performs a strncpy, assuming it will not exceed the boundaries of the array. While the use of \"short s\" is forced in this particular example, short int's are frequently used within real-world code, such as code that processes structured data.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": [{"@style": "margin-left:1em;", "#text": "return(0x0000FFFF);"}, {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "#text": "DiePainfully(\"go away!\\n\");"}, "#text": "char path[256];char *input;int i;short s;unsigned int sz;\n                           i = GetUntrustedInt();s = i;/* s is -1 so it passes the safety check - CWE-697 */if (s > 256) {}\n                           /* s is sign-extended and saved in sz */sz = s;\n                           /* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */printf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\n                           input = GetUserInput(\"Enter pathname:\");\n                           /* strncpy interprets s as unsigned int, so it's treated as MAX_INT(CWE-195), enabling buffer overflow (CWE-119) */strncpy(path, input, s);path[255] = '\\0'; /* don't want CWE-170 */printf(\"Path is: %s\\n\", path);"}}], "xhtml:br": [null, null], "#text": "int GetUntrustedInt () {}\n                     void main (int argc, char **argv) {}"}}, "Body_Text": "This code first exhibits an example of CWE-839, allowing \"s\" to be a negative number. When the negative short \"s\" is converted to an unsigned integer, it becomes an extremely large positive integer. When this converted integer is used by strncpy() it will lead to a buffer overflow (CWE-119)."}, {"@Demonstrative_Example_ID": "DX-100", "Intro_Text": "In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method", "Example_Code": [{"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:i": ["// check that the array index is less than the maximum", "// length of the array", "// if array index is invalid then output error message", "// and return value indicating error"], "xhtml:div": [{"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null], "xhtml:i": "// get the value at the specified index of the array", "#text": "value = array[index];"}}, {"@style": "margin-left:1em;", "xhtml:br": null, "#text": "printf(\"Value is: %d\\n\", array[index]);value = -1;"}], "#text": "int value;\n                           \n                           \n                           \n                           \n                           \n                           if (index < len) {}\n                           \n                           \n                           \n                           \n                           else {}\n                           return value;"}}, "#text": "int getValueFromArray(int *array, int len, int index) {}"}}, {"@Nature": "Good", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null], "xhtml:i": ["// check that the array index is within the correct", "// range of values for the array"], "#text": "...\n                     \n                     \n                     \n                     \n                     \n                     if (index >= 0 && index < len) {\n                     ..."}}], "Body_Text": "However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."}, {"Intro_Text": "The following code shows a simple BankAccount class with deposit and withdraw methods.", "Example_Code": [{"@Nature": "Bad", "@Language": "Java", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:i": ["// variable for bank account balance", "// constructor for BankAccount", "// method to deposit amount into BankAccount", "// method to withdraw amount from BankAccount", "// other methods for accessing the BankAccount object"], "xhtml:div": [{"@style": "margin-left:1em;", "#text": "accountBalance = 0;"}, {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null], "xhtml:div": [{"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null], "#text": "double newBalance = accountBalance - withdrawAmount;accountBalance = newBalance;"}}, {"@style": "margin-left:1em;", "xhtml:br": null, "#text": "System.err.println(\"Withdrawal amount exceeds the maximum limit allowed, please try again...\");..."}], "#text": "if (withdrawAmount < MAXIMUM_WITHDRAWAL_LIMIT) {}else {}"}}], "#text": "public final int MAXIMUM_WITHDRAWAL_LIMIT = 350;\n                           \n                           \n                           private double accountBalance;\n                           \n                           \n                           public BankAccount() {}\n                           \n                           \n                           public void deposit(double depositAmount) {...}\n                           \n                           \n                           public void withdraw(double withdrawAmount) {}\n                           \n                           \n                           ..."}}, "#text": "public class BankAccount {}"}}, {"@Nature": "Good", "@Language": "Java", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null], "xhtml:i": "// method to withdraw amount from BankAccount", "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": null, "#text": "..."}}, "#text": "if (withdrawAmount < MAXIMUM_WITHDRAWAL_LIMIT &&withdrawAmount > MINIMUM_WITHDRAWAL_LIMIT) {"}}, "#text": "public final int MINIMUM_WITHDRAWAL_LIMIT = 0;public final int MAXIMUM_WITHDRAWAL_LIMIT = 350;\n                           ...\n                           \n                           \n                           public void withdraw(double withdrawAmount) {"}}, "#text": "public class BankAccount {"}}], "Body_Text": ["The withdraw method includes a check to ensure that the withdrawal amount does not exceed the maximum limit allowed, however the method does not check to ensure that the withdrawal amount is greater than a minimum value (CWE-129). Performing a range check on a value that does not include a minimum check can have significant security implications, in this case not including a minimum range check can allow a negative value to be used which would cause the financial application using this class to deposit money into the user account rather than withdrawing. In this example the if statement should the modified to include a minimum range check, as shown below.", "Note that this example does not protect against concurrent access to the BankAccount balance variable, see CWE-413 and CWE-362.", "While it is out of scope for this example, note that the use of doubles or floats in financial calculations may be subject to certain kinds of attacks where attackers use rounding errors to steal money."]}]}, "Observed_Examples": {"Observed_Example": [{"Reference": "CVE-2010-1866", "Description": "Chain: integer overflow causes a negative signed value, which later bypasses a maximum-only check, leading to heap-based buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-1866"}, {"Reference": "CVE-2009-1099", "Description": "Chain: 16-bit counter can be interpreted as a negative value, compared to a 32-bit maximum value, leading to buffer under-write.", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-1099"}, {"Reference": "CVE-2011-0521", "Description": "Chain: kernel's lack of a check for a negative value leads to memory corruption.", "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0521"}, {"Reference": "CVE-2010-3704", "Description": "Chain: parser uses atoi() but does not check for a negative value, which can happen on some platforms, leading to buffer under-write.", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-3704"}, {"Reference": "CVE-2010-2530", "Description": "Chain: Negative value stored in an int bypasses a size check and causes allocation of large amounts of memory.", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-2530"}, {"Reference": "CVE-2009-3080", "Description": "Chain: negative offset value to IOCTL bypasses check for maximum index, then used as an array index for buffer under-read.", "Link": "https://www.cve.org/CVERecord?id=CVE-2009-3080"}, {"Reference": "CVE-2008-6393", "Description": "chain: file transfer client performs signed comparison, leading to integer overflow and heap-based buffer overflow.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-6393"}, {"Reference": "CVE-2008-4558", "Description": "chain: negative ID in media player bypasses check for maximum index, then used as an array index for buffer under-read.", "Link": "https://www.cve.org/CVERecord?id=CVE-2008-4558"}]}, "References": {"Reference": [{"@External_Reference_ID": "REF-62", "@Section": "Chapter 6, \"Type Conversion Vulnerabilities\" Page 246"}, {"@External_Reference_ID": "REF-62", "@Section": "Chapter 6, \"Comparisons\", Page 265"}]}, "Content_History": {"Submission": {"Submission_Name": "CWE Content Team", "Submission_Organization": "MITRE", "Submission_Date": "2011-03-24"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-06-01", "Modification_Comment": "updated Common_Consequences"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-05-11", "Modification_Comment": "updated Demonstrative_Examples, References, Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2014-02-18", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2018-03-27", "Modification_Comment": "updated Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2019-01-03", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-01-31", "Modification_Comment": "updated Alternate_Terms, Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated Relationships"}]}}, "copyright": "Copyright \u00a9 2006\u20132023, The MITRE Corporation. CWE, CWSS, CWRAF, and the CWE logo are trademarks of The MITRE Corporation.", "license": "CWE Usage: MITRE hereby grants you a non-exclusive, royalty-free license to use CWE for research, development, and commercial purposes. Any copy you make for such purposes is authorized on the condition that you reproduce MITRE\u2019s copyright designation and this license in any such copy."}