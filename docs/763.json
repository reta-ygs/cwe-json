{"cwe": {"@ID": "763", "@Name": "Release of Invalid Pointer or Reference", "@Abstraction": "Base", "@Structure": "Simple", "@Status": "Incomplete", "Description": "The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.", "Extended_Description": {"xhtml:p": "This weakness can take several forms, such as:", "xhtml:ul": {"xhtml:li": ["The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, non-compatible function (CWE-762).", "The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE-761."]}}, "Related_Weaknesses": {"Related_Weakness": [{"@Nature": "ChildOf", "@CWE_ID": "404", "@View_ID": "1000", "@Ordinal": "Primary"}, {"@Nature": "ChildOf", "@CWE_ID": "404", "@View_ID": "1003", "@Ordinal": "Primary"}, {"@Nature": "ChildOf", "@CWE_ID": "404", "@View_ID": "1340", "@Ordinal": "Primary"}]}, "Modes_Of_Introduction": {"Introduction": {"Phase": "Implementation"}}, "Common_Consequences": {"Consequence": {"Scope": ["Integrity", "Availability", "Confidentiality"], "Impact": ["Modify Memory", "DoS: Crash, Exit, or Restart", "Execute Unauthorized Code or Commands"], "Note": "This weakness may result in the corruption of memory, and perhaps instructions, possibly leading to a crash. If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code."}}, "Detection_Methods": {"Detection_Method": {"@Detection_Method_ID": "DM-13", "Method": "Fuzzing", "Description": "Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.", "Effectiveness": "High"}}, "Potential_Mitigations": {"Mitigation": [{"Phase": "Implementation", "Description": "Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free()."}, {"Phase": "Implementation", "Description": "When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory."}, {"@Mitigation_ID": "MIT-4.6", "Phase": "Architecture and Design", "Strategy": "Libraries or Frameworks", "Description": {"xhtml:p": ["Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.", "For example, glibc in Linux provides protection against free of invalid pointers."]}}, {"Phase": "Architecture and Design", "Description": "Use a language that provides abstractions for memory allocation and deallocation."}, {"Phase": "Testing", "Description": "Use a tool that dynamically detects memory management problems, such as valgrind."}]}, "Demonstrative_Examples": {"Demonstrative_Example": [{"@Demonstrative_Example_ID": "DX-78", "Intro_Text": "This code attempts to tokenize a string and place it into an array using the strsep function, which inserts a \\0 byte in place of whitespace or a tab character. After finishing the loop, each string in the AP array points to a location within the input string.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"@style": "margin-left:1em;", "#text": "break;"}, "#text": "if (++ap >= &argv[10])"}, "#text": "if (**ap != '\\0')"}}, "#text": "char **ap, *argv[10], *inputstring;for (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n                     /.../free(ap[4]);"}}, "Body_Text": "Since strsep is not allocating any new memory, freeing an element in the middle of the array is equivalent to free a pointer in the middle of inputstring."}, {"@Demonstrative_Example_ID": "DX-80", "Intro_Text": "This example allocates a BarObj object using the new operator in C++, however, the programmer then deallocates the object using free(), which may lead to unexpected behavior.", "Example_Code": [{"@Nature": "Bad", "@Language": "C++", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null], "xhtml:i": "/* do some work with ptr here */", "#text": "BarObj *ptr = new BarObj()\n                           \n                           \n                           ...\n                           free(ptr);"}}, "#text": "void foo(){}"}}, {"@Nature": "Good", "@Language": "C++", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null], "xhtml:i": "/* do some work with ptr here */", "#text": "BarObj *ptr = new BarObj()\n                           \n                           \n                           ...\n                           delete ptr;"}}, "#text": "void foo(){}"}}], "Body_Text": "Instead, the programmer should have either created the object with one of the malloc family functions, or else deleted the object with the delete operator."}, {"@Demonstrative_Example_ID": "DX-77", "Intro_Text": "In this example, the programmer dynamically allocates a buffer to hold a string and then searches for a specific character. After completing the search, the programmer attempts to release the allocated memory and return SUCCESS or FAILURE to the caller. Note: for simplification, this example uses a hard-coded \"Search Me!\" string and a constant string length of 20.", "Example_Code": [{"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null], "xhtml:i": "/* matched char, free string and return success */", "#text": "free(str);return SUCCESS;"}}, "xhtml:br": [null, null, null], "xhtml:i": "/* didn't match yet, increment pointer and try next char */", "#text": "if( *str == c ){}\n                                 \n                                 \n                                 str = str + 1;"}}, "xhtml:i": "/* we did not match the char in the string, free mem and return failure */", "#text": "char *str;str = (char*)malloc(20*sizeof(char));strcpy(str, \"Search Me!\");while( *str != NULL){}\n                           \n                           \n                           free(str);return FAILURE;"}}, "#text": "#define SUCCESS (1)#define FAILURE (0)\n                     int contains_char(char c){}"}}, {"@Nature": "Good", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null], "xhtml:i": "/* matched char, free string and return success */", "#text": "free(str);return SUCCESS;"}}, "xhtml:br": [null, null, null], "xhtml:i": "/* didn't match yet, increment pointer and try next char */", "#text": "if( str[i] == c ){}\n                                 \n                                 \n                                 i = i + 1;"}}, "xhtml:i": "/* we did not match the char in the string, free mem and return failure */", "#text": "char *str;int i = 0;str = (char*)malloc(20*sizeof(char));strcpy(str, \"Search Me!\");while( i < strlen(str) ){}\n                           \n                           \n                           free(str);return FAILURE;"}}, "#text": "#define SUCCESS (1)#define FAILURE (0)\n                     int cointains_char(char c){}"}}], "Body_Text": ["However, if the character is not at the beginning of the string, or if it is not in the string at all, then the pointer will not be at the start of the buffer when the programmer frees it.", "Instead of freeing the pointer in the middle of the buffer, the programmer can use an indexing pointer to step through the memory or abstract the memory calculations by using array indexing."]}, {"@Demonstrative_Example_ID": "DX-79", "Intro_Text": "Consider the following code in the context of a parsing application to extract commands out of user data. The intent is to parse each command and add it to a queue of commands to be executed, discarding each malformed entry.", "Example_Code": [{"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null], "xhtml:i": ["//hardcode input length for simplicity", "/* The following loop will parse and process each token in the input string */"], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:div": [{"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null], "xhtml:i": "/* ignore and discard bad data */", "#text": "free( tok );"}}, {"@style": "margin-left:1em;", "#text": "add_to_command_queue( tok );"}], "xhtml:br": [null, null], "#text": "if( isMalformed( tok ) ){}else{}tok = strtok( NULL, sep));"}}, "#text": "char* input = (char*) malloc(40*sizeof(char));char *tok;char* sep = \" \\t\";\n                     get_user_input( input );\n                     \n                     \n                     \n                     tok = strtok( input, sep);while( NULL != tok ){}"}}, {"@Nature": "Good", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:i": ["//hardcode input length for simplicity", "/* The following loop will parse and process each token in the input string */"], "xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:div": {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null], "xhtml:i": "/* copy and enqueue good data */", "#text": "command = (char*) malloc( (strlen(tok) + 1) * sizeof(char) );strcpy( command, tok );add_to_command_queue( command );"}}, "xhtml:br": null, "#text": "if( !isMalformed( command ) ){}tok = strtok( NULL, sep));"}}, "#text": "char* input = (char*) malloc(40*sizeof(char));char *tok, *command;char* sep = \" \\t\";\n                     get_user_input( input );\n                     \n                     \n                     \n                     tok = strtok( input, sep);while( NULL != tok ){}\n                     free( input )"}}], "Body_Text": ["While the above code attempts to free memory associated with bad commands, since the memory was all allocated in one chunk, it must all be freed together.", "One way to fix this problem would be to copy the commands into a new memory location before placing them in the queue. Then, after all commands have been processed, the memory can safely be freed."]}]}, "Affected_Resources": {"Affected_Resource": "Memory"}, "Taxonomy_Mappings": {"Taxonomy_Mapping": {"@Taxonomy_Name": "Software Fault Patterns", "Entry_ID": "SFP12", "Entry_Name": "Faulty Memory Release"}}, "References": {"Reference": [{"@External_Reference_ID": "REF-657"}, {"@External_Reference_ID": "REF-480"}]}, "Notes": {"Note": {"@Type": "Maintenance", "#text": "The view-1000 subtree that is associated with this weakness needs additional work. Several entries will likely be created in this branch. Currently the focus is on free() of memory, but delete and other related release routines may require the creation of intermediate entries that are not specific to a particular function. In addition, the role of other types of invalid pointers, such as an expired pointer, i.e. CWE-415 Double Free and release of uninitialized pointers, related to CWE-457."}}, "Content_History": {"Submission": {"Submission_Name": "CWE Content Team", "Submission_Organization": "MITRE", "Submission_Date": "2009-05-08"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2010-06-21", "Modification_Comment": "updated Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2010-09-27", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-06-01", "Modification_Comment": "updated Common_Consequences"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-05-11", "Modification_Comment": "updated Common_Consequences, Demonstrative_Examples, Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-10-30", "Modification_Comment": "updated Potential_Mitigations"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2014-02-18", "Modification_Comment": "updated Potential_Mitigations"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2014-07-30", "Modification_Comment": "updated Relationships, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2017-11-08", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2019-06-20", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-02-24", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-12-10", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2021-03-15", "Modification_Comment": "updated Maintenance_Notes"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-01-31", "Modification_Comment": "updated Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated Detection_Factors, References, Relationships"}]}}, "copyright": "Copyright \u00a9 2006\u20132023, The MITRE Corporation. CWE, CWSS, CWRAF, and the CWE logo are trademarks of The MITRE Corporation.", "license": "CWE Usage: MITRE hereby grants you a non-exclusive, royalty-free license to use CWE for research, development, and commercial purposes. Any copy you make for such purposes is authorized on the condition that you reproduce MITRE\u2019s copyright designation and this license in any such copy."}