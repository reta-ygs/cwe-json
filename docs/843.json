{"cwe": {"@ID": "843", "@Name": "Access of Resource Using Incompatible Type ('Type Confusion')", "@Abstraction": "Base", "@Structure": "Simple", "@Status": "Incomplete", "Description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.", "Extended_Description": {"xhtml:p": ["When the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.", "While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.", "This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues."]}, "Related_Weaknesses": {"Related_Weakness": [{"@Nature": "ChildOf", "@CWE_ID": "704", "@View_ID": "1000", "@Ordinal": "Primary"}, {"@Nature": "ChildOf", "@CWE_ID": "704", "@View_ID": "1003", "@Ordinal": "Primary"}, {"@Nature": "CanPrecede", "@CWE_ID": "119", "@View_ID": "1000"}]}, "Applicable_Platforms": {"Language": [{"@Name": "C", "@Prevalence": "Undetermined"}, {"@Name": "C++", "@Prevalence": "Undetermined"}]}, "Alternate_Terms": {"Alternate_Term": {"Term": "Object Type Confusion"}}, "Modes_Of_Introduction": {"Introduction": {"Phase": "Implementation"}}, "Common_Consequences": {"Consequence": {"Scope": ["Availability", "Integrity", "Confidentiality"], "Impact": ["Read Memory", "Modify Memory", "Execute Unauthorized Code or Commands", "DoS: Crash, Exit, or Restart"], "Note": "When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution."}}, "Demonstrative_Examples": {"Demonstrative_Example": [{"Intro_Text": "The following code uses a union to support the representation of different types of messages. It formats messages differently, depending on their type.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null], "xhtml:div": [{"@style": "margin-left:1em;", "xhtml:br": null, "xhtml:div": {"@style": "margin-left:1em;", "xhtml:br": null, "#text": "char *name;int nameID;"}, "#text": "int msgType;union {};"}, {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null], "xhtml:i": "/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */", "xhtml:div": [{"@style": "margin-left:1em;", "#text": "printf(\"Message: %s\\n\", buf.name);"}, {"@style": "margin-left:1em;", "#text": "printf(\"Message: Use ID %d\\n\", buf.nameID);"}], "#text": "struct MessageBuffer buf;char *defaultMessage = \"Hello World\";\n                           buf.msgType = NAME_TYPE;buf.name = defaultMessage;printf(\"Pointer of buf.name is %p\\n\", buf.name);\n                           \n                           \n                           buf.nameID = (int)(defaultMessage + 1);printf(\"Pointer of buf.name is now %p\\n\", buf.name);if (buf.msgType == NAME_TYPE) {}else {}"}}], "#text": "#define NAME_TYPE 1#define ID_TYPE 2\n                     struct MessageBuffer{};\n                     \n                     int main (int argc, char **argv) {}"}}, "Body_Text": ["The code intends to process the message as a NAME_TYPE, and sets the default message to \"Hello World.\" However, since both buf.name and buf.nameID are part of the same union, they can act as aliases for the same memory location, depending on memory layout after compilation.", "As a result, modification of buf.nameID - an int - can effectively modify the pointer that is stored in buf.name - a string.", "Execution of the program might generate output such as:", {"xhtml:div": {"xhtml:div": ["Pointer of name is 10830", "Pointer of name is now 10831", "Message: ello World"]}}, "Notice how the pointer for buf.name was changed, even though buf.name was not explicitly modified.", "In this case, the first \"H\" character of the message is omitted. However, if an attacker is able to fully control the value of buf.nameID, then buf.name could contain an arbitrary pointer, leading to out-of-bounds reads or writes."]}, {"Intro_Text": "The following PHP code accepts a value, adds 5, and prints the sum.", "Example_Code": {"@Nature": "Bad", "@Language": "PHP", "xhtml:div": {"xhtml:br": [null, null, null], "#text": "$value = $_GET['value'];$sum = $value + 5;echo \"value parameter is '$value'<p>\";echo \"SUM is $sum\";"}}, "Body_Text": ["When called with the following query string:", {"xhtml:div": {"xhtml:div": "value=123"}}, "the program calculates the sum and prints out:", {"xhtml:div": {"xhtml:div": "SUM is 128"}}, "However, the attacker could supply a query string such as:", {"xhtml:div": {"xhtml:div": "value[]=123"}}, "The \"[]\" array syntax causes $value to be treated as an array type, which then generates a fatal error when calculating $sum:", {"xhtml:div": {"xhtml:div": "Fatal error: Unsupported operand types in program.php on line 2"}}]}, {"Intro_Text": "The following Perl code is intended to look up the privileges for user ID's between 0 and 3, by performing an access of the $UserPrivilegeArray reference. It is expected that only userID 3 is an admin (since this is listed in the third element of the array).", "Example_Code": {"@Nature": "Bad", "@Language": "Perl", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null], "xhtml:div": [{"@style": "margin-left:1em;", "#text": "print \"Regular user!\\n\";"}, {"@style": "margin-left:1em;", "#text": "print \"Admin!\\n\";"}], "#text": "my $UserPrivilegeArray = [\"user\", \"user\", \"admin\", \"user\"];\n                     my $userID = get_current_user_ID();\n                     if ($UserPrivilegeArray eq \"user\") {}else {}\n                     print \"\\$UserPrivilegeArray = $UserPrivilegeArray\\n\";"}}, "Body_Text": ["In this case, the programmer intended to use \"$UserPrivilegeArray->{$userID}\" to access the proper position in the array. But because the subscript was omitted, the \"user\" string was compared to the scalar representation of the $UserPrivilegeArray reference, which might be of the form \"ARRAY(0x229e8)\" or similar.", "Since the logic also \"fails open\" (CWE-636), the result of this bug is that all users are assigned administrator privileges.", "While this is a forced example, it demonstrates how type confusion can have security consequences, even in memory-safe languages."]}]}, "Observed_Examples": {"Observed_Example": [{"Reference": "CVE-2010-4577", "Description": "Type confusion in CSS sequence leads to out-of-bounds read.", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-4577"}, {"Reference": "CVE-2011-0611", "Description": "Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.", "Link": "https://www.cve.org/CVERecord?id=CVE-2011-0611"}, {"Reference": "CVE-2010-0258", "Description": "Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.", "Link": "https://www.cve.org/CVERecord?id=CVE-2010-0258"}]}, "Taxonomy_Mappings": {"Taxonomy_Mapping": {"@Taxonomy_Name": "CERT C Secure Coding", "Entry_ID": "EXP39-C", "Entry_Name": "Do not access a variable through a pointer of an incompatible type", "Mapping_Fit": "Exact"}}, "References": {"Reference": [{"@External_Reference_ID": "REF-811", "@Section": "\"Type Confusion Vulnerabilities,\" page 59"}, {"@External_Reference_ID": "REF-62", "@Section": "Chapter 7, \"Type Confusion\", Page 319"}]}, "Notes": {"Note": [{"@Type": "Applicable Platform", "xhtml:p": "This weakness is possible in any type-unsafe programming language."}, {"@Type": "Research Gap", "xhtml:p": ["Type confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as \"memory corruption\" instead.", "For other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential \"type confusion\" behavior might be intentional, possibly requiring more manual analysis."]}]}, "Content_History": {"Submission": {"Submission_Name": "CWE Content Team", "Submission_Organization": "MITRE", "Submission_Date": "2011-05-15"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-05-11", "Modification_Comment": "updated References"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2017-11-08", "Modification_Comment": "updated Applicable_Platforms, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2019-01-03", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2019-06-20", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-02-24", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-06-25", "Modification_Comment": "updated Common_Consequences, Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2022-04-28", "Modification_Comment": "updated Research_Gaps"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-01-31", "Modification_Comment": "updated Description"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated References, Relationships"}]}}, "copyright": "Copyright \u00a9 2006\u20132023, The MITRE Corporation. CWE, CWSS, CWRAF, and the CWE logo are trademarks of The MITRE Corporation.", "license": "CWE Usage: MITRE hereby grants you a non-exclusive, royalty-free license to use CWE for research, development, and commercial purposes. Any copy you make for such purposes is authorized on the condition that you reproduce MITRE\u2019s copyright designation and this license in any such copy."}