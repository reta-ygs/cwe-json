{"cwe": {"@ID": "192", "@Name": "Integer Coercion Error", "@Abstraction": "Variant", "@Structure": "Simple", "@Status": "Incomplete", "Description": "Integer coercion refers to a set of flaws pertaining to the type casting, extension, or truncation of primitive data types.", "Extended_Description": "Several flaws fall under the category of integer coercion errors. For the most part, these errors in and of themselves result only in availability and data integrity issues. However, in some circumstances, they may result in other, more complicated security related flaws, such as buffer overflow conditions.", "Related_Weaknesses": {"Related_Weakness": {"@Nature": "ChildOf", "@CWE_ID": "681", "@View_ID": "1000", "@Ordinal": "Primary"}}, "Applicable_Platforms": {"Language": [{"@Name": "C", "@Prevalence": "Undetermined"}, {"@Name": "C++", "@Prevalence": "Undetermined"}, {"@Name": "Java", "@Prevalence": "Undetermined"}, {"@Name": "C#", "@Prevalence": "Undetermined"}]}, "Modes_Of_Introduction": {"Introduction": {"Phase": "Implementation"}}, "Likelihood_Of_Exploit": "Medium", "Common_Consequences": {"Consequence": [{"Scope": "Availability", "Impact": ["DoS: Resource Consumption (CPU)", "DoS: Resource Consumption (Memory)", "DoS: Crash, Exit, or Restart"], "Note": "Integer coercion often leads to undefined states of execution resulting in infinite loops or crashes."}, {"Scope": ["Integrity", "Confidentiality", "Availability"], "Impact": "Execute Unauthorized Code or Commands", "Note": "In some cases, integer coercion errors can lead to exploitable buffer overflow conditions, resulting in the execution of arbitrary code."}, {"Scope": ["Integrity", "Other"], "Impact": "Other", "Note": "Integer coercion errors result in an incorrect value being stored for the variable in question."}]}, "Detection_Methods": {"Detection_Method": {"@Detection_Method_ID": "DM-14", "Method": "Automated Static Analysis", "Description": "Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)", "Effectiveness": "High"}}, "Potential_Mitigations": {"Mitigation": [{"Phase": "Requirements", "Description": "A language which throws exceptions on ambiguous data casts might be chosen."}, {"Phase": "Architecture and Design", "Description": "Design objects and program flow such that multiple or complex casts are unnecessary"}, {"Phase": "Implementation", "Description": "Ensure that any data type casting that you must used is entirely understood in order to reduce the plausibility of error in use."}]}, "Demonstrative_Examples": {"Demonstrative_Example": [{"@Demonstrative_Example_ID": "DX-21", "Intro_Text": "The following code is intended to read an incoming packet from a socket and extract one or more headers.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "#text": "ExitError(\"too many headers!\");"}, "#text": "DataPacket *packet;int numHeaders;PacketHeader *headers;\n                     sock=AcceptSocketConnection();ReadPacket(packet, sock);numHeaders =packet->headers;\n                     if (numHeaders > 100) {}headers = malloc(numHeaders * sizeof(PacketHeader);ParsePacketHeaders(packet, headers);"}}, "Body_Text": "The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}, {"@Demonstrative_Example_ID": "DX-23", "Intro_Text": "The following code reads a maximum size and performs validation on that size. It then performs a strncpy, assuming it will not exceed the boundaries of the array. While the use of \"short s\" is forced in this particular example, short int's are frequently used within real-world code, such as code that processes structured data.", "Example_Code": {"@Nature": "Bad", "@Language": "C", "xhtml:div": {"xhtml:div": [{"@style": "margin-left:1em;", "#text": "return(0x0000FFFF);"}, {"@style": "margin-left:1em;", "xhtml:div": {"xhtml:br": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "xhtml:div": {"@style": "margin-left:1em;", "#text": "DiePainfully(\"go away!\\n\");"}, "#text": "char path[256];char *input;int i;short s;unsigned int sz;\n                           i = GetUntrustedInt();s = i;/* s is -1 so it passes the safety check - CWE-697 */if (s > 256) {}\n                           /* s is sign-extended and saved in sz */sz = s;\n                           /* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */printf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\n                           input = GetUserInput(\"Enter pathname:\");\n                           /* strncpy interprets s as unsigned int, so it's treated as MAX_INT(CWE-195), enabling buffer overflow (CWE-119) */strncpy(path, input, s);path[255] = '\\0'; /* don't want CWE-170 */printf(\"Path is: %s\\n\", path);"}}], "xhtml:br": [null, null], "#text": "int GetUntrustedInt () {}\n                     void main (int argc, char **argv) {}"}}, "Body_Text": "This code first exhibits an example of CWE-839, allowing \"s\" to be a negative number. When the negative short \"s\" is converted to an unsigned integer, it becomes an extremely large positive integer. When this converted integer is used by strncpy() it will lead to a buffer overflow (CWE-119)."}]}, "Taxonomy_Mappings": {"Taxonomy_Mapping": [{"@Taxonomy_Name": "CLASP", "Entry_Name": "Integer coercion error"}, {"@Taxonomy_Name": "CERT C Secure Coding", "Entry_ID": "INT02-C", "Entry_Name": "Understand integer conversion rules"}, {"@Taxonomy_Name": "CERT C Secure Coding", "Entry_ID": "INT05-C", "Entry_Name": "Do not use input functions to convert character data if they cannot handle all possible inputs"}, {"@Taxonomy_Name": "CERT C Secure Coding", "Entry_ID": "INT31-C", "Entry_Name": "Ensure that integer conversions do not result in lost or misinterpreted data", "Mapping_Fit": "Exact"}]}, "References": {"Reference": [{"@External_Reference_ID": "REF-44", "@Section": "\"Sin 7: Integer Overflows.\" Page 119"}, {"@External_Reference_ID": "REF-62", "@Section": "Chapter 6, \"Sign Extension\", Page 248"}, {"@External_Reference_ID": "REF-18"}]}, "Notes": {"Note": {"@Type": "Maintenance", "#text": "Within C, it might be that \"coercion\" is semantically different than \"casting\", possibly depending on whether the programmer directly specifies the conversion, or if the compiler does it implicitly. This has implications for the presentation of this entry and others, such as CWE-681, and whether there is enough of a difference for these entries to be split."}}, "Content_History": {"Submission": {"Submission_Name": "CLASP", "Submission_Date": "2006-07-19"}, "Modification": [{"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2008-09-08", "Modification_Comment": "updated Applicable_Platforms, Common_Consequences, Maintenance_Notes, Relationships, Other_Notes, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2008-11-24", "Modification_Comment": "updated Relationships, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2009-12-28", "Modification_Comment": "updated Description, Other_Notes"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2010-04-05", "Modification_Comment": "updated Demonstrative_Examples"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-06-01", "Modification_Comment": "updated Common_Consequences"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2011-09-13", "Modification_Comment": "updated Relationships, Taxonomy_Mappings"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-05-11", "Modification_Comment": "updated Demonstrative_Examples, References"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2012-10-30", "Modification_Comment": "updated Potential_Mitigations"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2017-11-08", "Modification_Comment": "updated Relationships, Taxonomy_Mappings, Type"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2019-01-03", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2020-02-24", "Modification_Comment": "updated Relationships"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2021-03-15", "Modification_Comment": "updated Demonstrative_Examples, Maintenance_Notes, References"}, {"Modification_Name": "CWE Content Team", "Modification_Organization": "MITRE", "Modification_Date": "2023-04-27", "Modification_Comment": "updated Detection_Factors, Relationships"}]}}, "copyright": "Copyright \u00a9 2006\u20132023, The MITRE Corporation. CWE, CWSS, CWRAF, and the CWE logo are trademarks of The MITRE Corporation.", "license": "CWE Usage: MITRE hereby grants you a non-exclusive, royalty-free license to use CWE for research, development, and commercial purposes. Any copy you make for such purposes is authorized on the condition that you reproduce MITRE\u2019s copyright designation and this license in any such copy."}